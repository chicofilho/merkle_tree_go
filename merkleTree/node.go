package merkleTree

/*
*	The representation of a node in the tree
*	If the node has children is not a leaf
*
* 	The node carries its children; the content and the calculated hash
 */

type Node struct {
	Right   *Node
	Left    *Node
	Parent  *Node
	Content []byte
	Hash    Hash
}

// Check if node is a leaf
func (n *Node) IsLeaf() bool {
	if n.Right != nil || n.Left != nil {
		return false
	}
	return true
}

// Check if node is a root
func (n *Node) isRoot() bool {
	if n.Parent != nil {
		return false
	}
	return true
}

// check if node is a left child
func (n *Node) isLeftChild() bool {
	if n.Parent.Left == n {
		return true
	}
	return false
}

// get nodes sibling
func (n *Node) getSibling() *Node {
	if n.isRoot() {
		return nil
	}

	if n.isLeftChild() {
		return n.Parent.Right
	} else {
		return n.Parent.Left
	}

}

/* Function for generating the hash of a node
* If the node is a leaf the hash will be based on the content
* If the node isn't a leaf the hash will be generated by the sum of the children's hashes
 */
func (n *Node) GenerateHash() {
	if n.Right != nil && n.Left != nil { // non-leaf node
		leftHash := n.Left.GetHash()
		rightHash := n.Right.GetHash()
		n.Hash = calculateHashFromBytes(append(leftHash[:], rightHash[:]...))
	} else { // leaf node
		n.Hash = calculateHashFromBytes(n.Content)
	}
}

// getHash generates the hash once and saves the information within the node
func (n *Node) GetHash() Hash {
	if n.Hash == [20]byte{} {
		n.GenerateHash()
	}

	return n.Hash
}

// Pasing a hash sequence to string
func (n *Node) getHashString() string {
	return n.GetHash().ToString()
}

// Adding leafs to a node
func (n *Node) addLeafs(leftNode *Node, rightNode *Node) {
	n.Left = leftNode
	n.Right = rightNode
	leftNode.Parent = n
	rightNode.Parent = n
	n.GenerateHash()
}

// Adding leafs by bytes
func (n *Node) addLeafsBytes(left []byte, right []byte) {
	n.addLeafs(&Node{Content: left}, &Node{Content: right})
}
